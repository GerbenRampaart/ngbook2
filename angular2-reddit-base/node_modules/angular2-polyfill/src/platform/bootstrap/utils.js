"use strict";
var camelcase = require('camelcase');
var dotProp = require('dot-prop');
var component_1 = require('./component');
var directive_1 = require('./directive');
var pipe_1 = require('./pipe');
var injectable_1 = require('./injectable');
function parseHostBinding(key) {
    var regex = [
        { type: 'attr', regex: /^([a-zA-Z]+)$/ },
        { type: 'prop', regex: /^\[([a-zA-Z\.-]+)\]$/ },
        { type: 'event', regex: /^\(([a-zA-Z]+)\)$/ }
    ];
    for (var i = 0; i < regex.length; i++) {
        var match = key.match(regex[i].regex);
        if (match !== null) {
            return { type: regex[i].type, value: match[1] };
        }
    }
    ;
    return { type: undefined, value: key };
}
function applyValueToProperties(el, properties, value) {
    properties.forEach(function (property) {
        var splitted = property.split('.');
        if (splitted.length === 1) {
            // Set the property directly
            el.prop(camelcase(property), value);
        }
        else {
            var root = splitted.shift();
            if (root === 'class') {
                // Handle adding/removing class names
                var method = value ? 'addClass' : 'removeClass';
                el[method](splitted.join('.'));
            }
            else {
                // Handle deeply nested properties
                var runner = el.prop(camelcase(root));
                while (splitted.length > 1) {
                    runner = runner[camelcase(splitted.shift())];
                }
                runner[camelcase(splitted.shift())] = value;
            }
        }
    });
}
function inject(target) {
    var annotations = target.__annotations__ || {};
    var injectables = [];
    if (annotations.inject) {
        annotations.inject.forEach(function (injectable, index) {
            if (typeof injectable === 'string') {
                injectables[index] = injectable;
            }
            else if (injectable) {
                injectables[index] = injectable.name;
            }
        });
    }
    if (Reflect.hasMetadata('design:paramtypes', target)) {
        Reflect.getMetadata('design:paramtypes', target).forEach(function (type, index) {
            if (type.name !== 'Object') {
                injectables[index] = type.name;
            }
        });
    }
    target.$inject = injectables;
}
exports.inject = inject;
function bindInput(target, directive) {
    var annotations = target.__annotations__;
    var component = annotations.component || annotations.directive;
    function signOf(key) {
        if (Reflect.hasMetadata('design:type', target.prototype, key)) {
            var type = Reflect.getMetadata('design:type', target.prototype, key);
            if (type.name === 'String') {
                return '@';
            }
            else {
                return '=';
            }
        }
        return '@';
    }
    // Bind all the elements in the `inputs` array
    (component.inputs || []).forEach(function (key) {
        var mapping = key.split(/:[ ]*/);
        directive.bindToController[mapping[0]] = signOf(key) + (mapping[1] || mapping[0]);
    });
    // Bind all the elements in the `@Input` annotation list
    Object.keys(annotations.inputs || {}).forEach(function (key) {
        directive.bindToController[key] = signOf(key) + annotations.inputs[key];
    });
}
exports.bindInput = bindInput;
function bindOutput(target, directive) {
    var annotations = target.__annotations__;
    var component = annotations.component || annotations.directive;
    // Bind all the elements in the `outputs` array or in the `@Output` annotation list
    (component.outputs || []).forEach(function (key) {
        var mapping = key.split(/:[ ]*/);
        directive.bindToController[mapping[0]] = '&' + (mapping[1] || mapping[0]);
    });
    Object.keys(annotations.outputs || {}).forEach(function (key) { return directive.bindToController[key] = "&" + annotations.outputs[key]; });
}
exports.bindOutput = bindOutput;
function parseHosts(hostBindings) {
    var result = {
        attrs: {},
        events: {},
        props: {
            raw: {},
            expressions: {}
        }
    };
    Object.keys(hostBindings).forEach(function (key) {
        var value = hostBindings[key];
        var parsed = parseHostBinding(key);
        if (parsed.type === 'attr') {
            result.attrs[parsed.value] = value;
        }
        else if (parsed.type === 'event') {
            var handler = value.match(/^([a-zA-Z]+)\((.*?)\)$/);
            var method = handler[1];
            var params = handler[2].length === 0 ? [] : handler[2].split(/,[ ]*/);
            result.events[parsed.value] = { method: method, params: params };
        }
        else if (parsed.type === 'prop') {
            var raw = value.match(/^['"](.*?)['"]$/);
            var map = 'expressions';
            if (raw) {
                // If the value is escaped, it's a raw value and should be applied directly
                value = raw[1];
                map = 'raw';
            }
            result.props[map][value] = result.props[map][value] || [];
            result.props[map][value].push(parsed.value);
        }
    });
    return result;
}
exports.parseHosts = parseHosts;
function bindHostBindings(scope, el, hostBindings, controllerAs) {
    if (controllerAs === void 0) { controllerAs = '$ctrl'; }
    // Handle attributes
    Object.keys(hostBindings.attrs).forEach(function (attribute) {
        el.attr(attribute, hostBindings.attrs[attribute]);
    });
    // Handle host listeners
    Object.keys(hostBindings.events).forEach(function (event) {
        var target = hostBindings.events[event];
        el.bind(event, function (e) {
            var ctx = { $event: e };
            // use scope.$apply because we are outside the angular digest cycle
            scope.$apply(function () {
                scope[controllerAs][target.method].apply(scope[controllerAs], target.params.map(function (param) { return dotProp.get(ctx, param); }));
            });
        });
    });
    // Handle host property bindings
    Object.keys(hostBindings.props.raw).forEach(function (value) {
        var properties = hostBindings.props.raw[value];
        applyValueToProperties(el, properties, value);
    });
    Object.keys(hostBindings.props.expressions).forEach(function (expression) {
        var properties = hostBindings.props.expressions[expression];
        scope.$watch(controllerAs + "." + expression, function (newValue) {
            applyValueToProperties(el, properties, newValue);
        });
    });
}
exports.bindHostBindings = bindHostBindings;
function bootstrapHelper(ngModule, target) {
    if (Array.isArray(target)) {
        return target.forEach(function (target) { return bootstrapHelper(ngModule, target); });
    }
    if (target.__annotations__) {
        if (target.__annotations__.component) {
            return component_1.bootstrap(ngModule, target);
        }
        else if (target.__annotations__.directive) {
            return directive_1.bootstrap(ngModule, target);
        }
        else if (target.__annotations__.pipe) {
            return pipe_1.bootstrap(ngModule, target);
        }
    }
    return injectable_1.bootstrap(ngModule, target);
}
exports.bootstrapHelper = bootstrapHelper;
